// eslint-disable-next-line import/prefer-default-export
export const desc347 = `
  높잇값 변경을 검사할 div 요소의 ref 객체를 정의한다.
  데이터가 추가되기 직전의 div의 높잇값 반환한다.
  getSnapshotBeforeUpdate 메서드에서 반환한 값이 componentDidUpdate 메서드의 세 번째 매개변수로 들어온다.
  높잇값이 변경되면 알림창을 띄운다.
  div 요소 안에 데이터 개수만큼의 span 요소를 넣기 때문에 개수에 따라 div 요소의 높이가 변한다.
  앞의 코드를 실행해서 버튼을 계속해서 클릭하면 div 요소의 높잇값이 변경될 때마다 알림창이 뜨는 것을 확인할 수 있다.
`;

export const desc348 = `
  div 요소의 가로 길이보다 스크롤 영역의 가로 길이가 더 크면 스크롤이 가능하다고 알려 준다.
  스크롤이 가능하도록 overflow: 'scroll' 속성을 준다.
  text 상탯값의 문자열이 충분히 길어지면 div 요소 내부는 스크롤이 가능해진다.
`;

export const desc349 = `
  componentDidUpdate 메서드 내부에서는 이전, 이후의 상탯값과 속성값을 모두 알 수 있기 때문에 이와 같은 코드를 자주 작성하게 된다.
  componentDidUpdate 메서드는 초기화 단계에서는 호출되지 않는다.
  친구 목록을 가져오는 API는 componentDidMount 메서드에서도 호출할 필요가 있다.
`;

export const desc350 = `
  componentDidMount 메서드와 componentDidUpdate 메서드 양쪽에서 친구 목록을 가져온다.
  실제로 이와 같은 패턴이 자주 사용되지만, 단지 componentDidUpdate 메서드가 첫 렌더링 후에 호출되지 않는다는 이유로 코드가 복잡해진다.
  비슷한 로직을 양쪽 모두에 작성하기 때문에 코드 중복이 발생하고, 한쪽에 코드를 작성하는 것을 깜빡해서 버그가 생기기도 한다.
  이 문제는 리액트 훅을 이용하면 쉽게 해결할 수 있다.
`;

export const desc351 = `
  이와 같은 패턴은 두 생명 주기 메서드의 코드가 길어질수록 서로 연관된 등록과 해제 코드가 물리적으로 멀어진다는 단점이 있다.
  등록하는 코드는 있고 해제하는 코드를 깜빡해서 버그가 생기는 경우도 종종 발생한다.
  componentDidUpdate의 경우와 마찬가지로 이 문제도 리액트 훅을 이용하면 쉽게 해결할 수 있다.
`;

export const desc352 = `
  자식 컴포넌트에서 예외가 발생하면 상탯값에 에러 정보를 저장한다.
  getDerivedStateFromError 메서드가 반환한 값은 기존 상탯값과 병합된다.
  componentDidCatch 메서드에서는 에러 정보를 서버로 전송한다.
  render 메서드에서는 에러가 존재하면 에러 정보를 렌더링하고, 에러가 없다면 자식 컴포넌트를 렌더링한다.
  ErrorBoundary 컴포넌트를 애플리케이션의 최상위 컴포넌트로 만들면 생명주기 메서드에서 발생하는 모든 예외를 처리할 수 있다.
`;

export const desc353 = `
  Counter 컴포넌트의 버튼을 세 번 클릭하면 예외가 발생한다.
  render 메서드는 생명 주기 메서드이므로 여기서 발생한 예외는 ErrorBoundary 컴포넌트에서 처리할 수 있다.
  ErrorBoundary 컴포넌트를 애플리케이션의 최상위 컴포넌트로 만들었다.
  따라서 자식 컴포넌트인 Counter 컴포넌트에서 발생하는 예외를 처리할 수 있다.
  ErrorBoundary 컴포넌트는 에플리케이션의 최상위 컴포넌트가 아니어도 된다.
  단, ErrorBoundary 컴포넌트의 자식 컴포넌트에서 발생한 예외만 처리할 수 있다.
  ErrorBoundary 컴포넌트를 여러 곳에서 사용해도 괜찮다
  그러면 예외가 발생한 일부 화면에만 에러 정보가 렌더링되고, 나머지 부분은 정상적으로 렌더링된다.
`;

export const desc354 = `
  이벤트 처리 메서드에서 발생하는 예외는 ErrorBoundary 컴포넌트로 처리되지 않는다
  이벤트 처리 메서드는 생명 주기 메서드가 아니기 때문이다.
  예외가 발생하기 전에 호출된 setState 메서드는 정상적으로 상탯값을 변경한다.
  예외가 발생한 코드 밑에 있는 setState 메서드는 호출되지 않는다
  이 경우 일부 상탯값만 변경되기 때문에 잘못된 정보가 사용자에게 노출될 수 있다.
`;

export const desc355 = `
  이벤트 처리 메서드에서 try catch 문을 이용해서 예외 처리를 해야 한다.
  예외 발생 시 상탯값을 롤백한다.
`;

export const desc356 = `
  보통 상위 컴포넌트에서 하위 컴포넌트로 데이터를 전달할 때 속성값이 사용되는데, 가까운 거리에 있는 몇 개의 하위 컴포넌트로 전달할 때는 속성값으로 충분하다.
  하지만 많은 수의 하위 컴포넌트로 전달할 때는 속성값을 내려 주는 코드를 반복적으로 작성해야 하는 문제가 있다.
  특히 하위 컴포넌트가 상위 컴포넌트에서 상당히 멀리 떨어져 있다면 중간에 있는 컴포넌트에서 기계적으로 속성값을 전달하는 코드를 작성해야 한다.
  이럴 때 컨텍스트 API를 사용하면 컴포넌트의 중첩 구조가 복잡한 상황에서도 비교적 쉽게 데이터를 전달할 수 있다.
  부모 컴포넌트에서 중간에 있는 Profile 컴포넌트로 속성값을 전달한다.
  Profile 컴포넌트는 username 속성값을 사용하지 않고 기계적으로 전달한다.
`;

export const desc357 = `
  컨텍스트 API를 사용하면 Profile 컴포넌트가 중간에 개입하지 않고도 속성값을 전달할 수 있다.
  createContext 함수를 호출하면 컨텍스트 객체가 생성된다.
  상위 컴포넌트에서는 Provider 컴포넌트를 이용해서 데이터를 사용한다.
  하위 컴포넌트에서는 Consumer 컴포넌트를 이용해서 데이터를 사용한다.
  Consumer 컴포넌트는 데이터를 찾기 위해 상위로 올라가면서 가장 가까운 Provider 컴포넌트를 찾는다.
  만약 최상위에 도달할 때까지 Provider 컴포넌트를 찾지 못한다면 기본값이 사용된다.
  Provider 컴포넌트의 속성값이 변경되면 하위의 모든 Consumer 컴포넌트는 다시 렌더링된다.
  한 가지 중요한 점은 중간에 위치한 컴포넌트의 shouldComponentUpdate 메서드에서 거짓을 반환해도 Consumer 컴포넌트는 다시 렌더링 된다는 점이다.
  createContext(defaultValue) => {Provider, Consumer}.
`;

export const desc359 = `
  username 상탯값이 변경되면, App 컴포넌트는 다시 렌더링된다.
  Profile 컴포넌트는 PureComponent로 만들어졌고 속성값과 상탯값이 없기 때문에 최초 렌더링 이후에는 다시 렌더링되지 않는다.
  Profile 컴포넌트의 렌더링 여부와 상관없이 Greeting 컴포넌트의 Consumer 컴포넌트는 다시 렌더링된다.
  따라서 중간 컴포넌트의 렌더링 여부와 상관없이 Provider 컴포넌트로 새로운 데이터가 입력되면 Consumer 컴포넌트가 다시 렌더링되는 것이 보장된다.
`;

export const desc360 = `
  두 개의 Provider 컴포넌트를 중첩해서 사용할 수 있다.
  마찬가지로 Consumer 컴포넌트도 중첩해서 사용할 수 있다.
  이 코드에서는 렌더링 성능상 이점이 없긴 하지만 보통의 경우 이렇게 데이터의 종류별로 컨텍스트를 만들어서 사용하면 렌더링 성능상 이점이 있다.
  이는 데이터 변경 시 해당 Consumer 컴포넌트만 렌더링 되기 때문이다.
`;

export const desc361 = `
  클래스 내부에서 컨텍스트 데이터에 접근하기 위해 contextType 정적 멤버변수에 콘텍스트 객체를 입력한다.
  생명 주기 메서드에서 context 멤버 변수를 통해서 컨텍스트 데이터를 사용할 수 있다.
  contextType을 이용한 방식은 하나의 컨텍스트만 연결할 수 있다는 단점이 있다.
  여러 개의 컨텍스트 데이터에 접근하고 싶다면 고차 컴포넌트를 이용한다.
`;

export const desc362 = `
  Consumer 컴포넌트를 이용해서 컨텍스트 데이터를 MyComponent 컴포넌트의 속성값으로 넣는다.
  이제 username, theme 데이터는 MyComponent 컴포넌트 내부의 모든 메서드에서 사용될 수 있다.
`;

export const desc363 = `
  helloCount를 증가시키는 함수를 컨텍스트 데이터에 포함시켰다.
  App 컴포넌트의 전체 상탯값을 컨텍스트 데이터를 관리하는 데 사용한다.
  App 컴포넌트의 onHello 메서드가 컨텍스트 데이터에 포함됐다.
  따라서 하위 컴포넌트에서 App 컴포넌트의 onHello 메서드를 호출할 수 있다.
  상탯값 전체를 컨텍스트 데이터로 전달한다.
  App 컴포넌트로부터 전달된 onHello 함수를 버튼에 등록한다.
  Greeting 컴포넌트의 버튼을 클릭하면 컨텍스트 데이터가 수정된다.
`;

export const desc365 = `
  컨텍스트 데이터로 객체를 사용할 때 주의하지 않으면 불필요한 렌더링이 발생할 수 있다.
  이 코드는 렌더링할 때마다 컨텍스트 데이터로 새로운 객체를 전달해서 불필요한 렌더링이 발생하는 예다.
  컨텍스트 데이터로 객체를 전달하고 있다.
  이처럼 작성하면 render 메서드가 호출될 때마다 새로운 객체가 생성된다. 따라서 name 값이 변경되지 않아도,
  render 메서드가 호출될 때마다 하위의 Consumer 컴포넌트도 다시 렌더링된다.
`;

export const desc366 = `
  컨텍스트 데이터 전체를 컴포넌트의 상탯값으로 관리한다.
  name 값이 변경되면 새로운 객체를 생성해서 상탯값에 저장한다.
  이제는 render 메서드 안에서 새로운 객체가 생성되지 않는다.
`;

export const desc358 = `
  Profile 컴포넌트 안쪽에서 사용된 Consumer 컴포넌트는 최상위에 도달할 때까지 Provider 컴포넌트를 찾지 못한다.
  따라서 컨텍스트 데이터의 기본값인 unknown이 사용된다.
`;

export const desc367 = `
  createRef 함수가 반환하는 ref 객체를 이용해서 자식 요소에 접근할 수 있다.
  접근하고자 하는 자식 요소의 ref 속성값에 ref 객체를 입력한다.
  해당 돔 요소 혹은 컴포넌트의 인스턴스가 생성되면 ref 객체로 접근할 수 있다.
  ref 객체의 current 속성을 이용하면 자식 요소에 접근할 수 있다.
`;

export const desc368 = `
  이전에 살펴봤던 TextInput 컴포넌트에 ref 속성값을 입력한다.
  컴포넌트에 ref 속성값을 사용하면 해당 컴포넌트의 메서드를 호출할 수 있다.
  버튼을 클릭하면 TextInput 컴포넌트의 setTextFocus 메서드가 호출되고, 자식 컴포넌트의 문자 입력창으로 포커스가 이동한다.
`;
